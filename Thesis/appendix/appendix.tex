\chapter{Appendix}

\section{Neuron M-Types and E-Types}
\begin{table}[h]
  %  \centering
    \begin{tabular}{r|l}
        DAC & Descending Axon Cell\\
        NGC-DA & Neurogliaform Cell with dense axonal arborization\\
        NGC-SA & Neurogliaform Cell with slender axonal arborization\\
        HAC & Horizontal Axon Cell\\
        LAC & Large Axon Cell\\
        SAC & Small Axon Cell\\
        MC & Martinotti Cell\\
        BTC & Bitufted Cell\\
        DBC & Double Bouquet Cell\\
        BP & Bipolar Cell\\
        NGC & Neurogliaform Cell\\
        LBC & Large Basket Cell\\
        NBC & Nest Basket Cell\\
        SBC & Small Basket Cell \\
        ChC & Chandelier Cell\\
        PC & Pyramidal Cell\\
        SP & Star Pyramidal Cell\\
        SS & Spiny Stellate Cell\\
        TTPC1 & Thick-tufted Pyramidal Cell with a late bifurcating apical tuft\\
        TTPC2 & Thick-tufted Pyramidal Cell with an early bifurcating apical tuft\\
        UTPC & Untufted Pyramidal Cell\\
        STPC & Slender-tufted Pyramidal Cell\\
        TPC\_L4 & Tufted Pyramidal Cell with apical dendrites terminating in layer 4\\
        TPC\_L1 & Tufted Pyramidal Cell with apical dendrites terminating in layer 1\\
        IPC & Pyramidal Cell with inverted apical-like dendrites\\
        BPC & Pyramidal Cell with bipolar apical-like dendrites\\
    \end{tabular}
    \caption{Neuron morphological types}
    \label{tab:m-type_table}
\end{table}

\begin{table}[h]
   % \centering
    \begin{tabular}{r|l}
        cADpyr & Continuous Accommodating (Adapting) for pyramidal cells\\
        cAC & Continuous Accommodating\\
        bAC & Burst Accommodating\\
        cNAC & Continuous Non-accommodating\\
        bNAC & Burst Non-accommodating\\
        dNAC & Delayed Non-accommodating\\
        cSTUT & Continuous Stuttering\\
        bSTUT & Burst Stuttering\\
        dSTUT & Delayed Stuttering\\
        cIR & Continuous Irregular\\
        bIR & Burst Irregular\\
    \end{tabular}
    \caption{Neuron electrical types}
    \label{tab:e-type_table}
\end{table}

\section{Pathway JSON data}
\begin{lstlisting}[caption={Sample JSON entry for pathway physiology}, label={ap:pathPhys}]
"L23_BTC:L4_LBC":{
    "gsyn_mean":0.33,
    "epsp_mean":0.8,
    "risetime_std":76,
    "f_std":4.9,
    "gsyn_std":0.15,
    "u_std":0.071,
    "decay_mean":170,
    "latency_mean":2.5,
    "failures_mean":2.8,
    "u_mean":0.25,
    "d_std":220,
    "synapse_type":"Inhibitory, depressing",
    "latency_std":0.75,
    "decay_std":99,
    "cv_psp_amplitude_std":0.093,
    "risetime_mean":73,
    "cv_psp_amplitude_mean":0.49,
    "epsp_std":0.5,
    "d_mean":710,
    "f_mean":21,
    "failures_std":5
}
\end{lstlisting}

\section{Network Descriptors}

\begin{lstlisting}[language=XML,label=lst:sampleNetXML, caption={Example of 2-cell network generated by NeurGen}]
<?xml version="1.0" ?>
<Neurtwork>
      <cells>
         <cell cellType="L1_DAC_bNAC219_1" id="0" label="Head"/>
         <cell cellType="L1_NGC-SA_cNAC187_1" id="1" label="Tail"/>
      </cells>
      <edges>
         <edge connCount="5" connType="0" delay="5.0" id="0" source="0"
               target="1" weight="2.0"/>
      </edges>
      <stimuli>
         <stim delay="0.0" target="0"/>
      </stimuli>
      <probes>
         <probe id="0" tag="L1_NGC-SA_0" target="0"/>
         <probe id="1" tag="L5_TTPC1_1" target="1"/>
      </probes>
</Neurtwork>
\end{lstlisting}

\begin{lstlisting}[language=XML,label=lst:4leafTop, caption={Topology template for 4-leaf Star topology}]
<?xml version="1.0" ?>
<Neurtwork>
  <cells>
     <cell cellType="L1_DAC_bNAC" id="0" label="Origin"/>
     <cell cellType="L2_.*" id="1" label="Node1"/>
     <cell cellType=".*" id="2" label="Node2"/>
     <cell cellType=".*" id="3" label="Node3"/>
     <cell cellType=".*" id="4" label="Node4"/>
  </cells>
  <edges>
     <edge id="0" source="0" target="1" />
     <edge id="1" source="0" target="2" />
     <edge id="2" source="0" target="3" />
     <edge id="3" source="0" target="4" />
  </edges>
  <stimuli>
     <stim id="0" target="0" />
  </stimuli>
  <probes>
     <probe id="0" target="0" label="OriginProbe" />
     <probe id="1" target="1" label="Node1Probe" />
     <probe id="2" target="2" label="Node2Probe" />
     <probe id="3" target="3" label="Node3Probe" />
     <probe id="4" target="4" label="Node4Probe" />
  </probes>
</Neurtwork>
\end{lstlisting}

\section{Simulation Code}

\subsection*{Network Generation Sample Code}
\begin{lstlisting}[language=Python,label=lst:netGenSamp, caption={Sample code for the generation of unique networks using NeurGen}]
import neurpy, os
# Create NeurGen object
ng = NeurGen( './modelBase/' )
# Load the statistical data from the BBP
ng.loadPathwayData( './NeurGen/physiology_pathways.json',
                    './NeurGen/anatomy_pathways.json' )
# Generate 10,000 random networks
for i in range( 10000 ):
    numCell = random.randint( 5, 20 )
    # Generate the network
    network = ng.createRandomNetwork( numCell )
    # Write the network to disk
    netPath = "./networks/net-%i.xml" % i
    with open( netPath, 'w' ) as netFile:
        netFile.write( network )
\end{lstlisting}

\subsection*{Neurpy Sample Code}
\begin{lstlisting}[language=Python,label=lst:sampleNrpyCode, caption={Sample code for the use of the Neurpy library}]
import neurpy
neurEnviron = neurpy.NeuronEnviron( './modelBase',   # BBP cell data
                                    './modelBase/globalMech' ) # Mechanisms
cellA = neurEn.createCell( 'L6_BP_bAC217_1' )  # Name of cell A
cellB = neurEn.createCell( 'L1_DAC_bNAC219_1' ) # Name of cell B
cellB.translate( [ 0.0, 100.0, 0.0 ] ) # Move cell B 100 um in Y axis
cellA.addChild( cellB, true, 6, 1.0, 1.0 ) # Connect cell A to cell B
if genGui:
    neurEn.generateGUI().createMainWindow() # Create GUI
else:
    neurEn.simulate( './simData.csv' ) # Run headless simulation
\end{lstlisting}

\subsection*{Concurrent Simulation Code}
\begin{lstlisting}[caption={Code for running concurrent simulations from supplied network files}, label={ap:simCode}, language=Python]
import os 
netDir = os.path.dirname( "./2cell_networks_l1force/" )
outDir = os.path.dirname( "./2cell_outputs_allSyn/" )

def runSim( netName, outName, pipe, affinity ):
    # We want isolated sessions, so keep these imports process-specific
    import neurpy
    from neurpy.NeuronEnviron import NeuronEnviron
    from neurpy.Neurtwork import Neurtwork
    import neuron
    import numpy as np
    import psutil
    
    # Assign ourselves to the correct CPU core
    p = psutil.Process()
    p.cpu_affinity( [ affinity ] )
    with open( "./thread-%i" % affinity, 'w' ) as f:
        # Redirect STDOUT and STDERR to file
        sys.stdout = f
        sys.stderr = f
        # Ensure the mechanisms are compiled
        if not os.path.exists( './x86_64' ):
            print( "WARNING: You're probably running without compiling\
                    the mechanisms first. This isn't recommended." )
        # Create a neurpy session
        netEnv = NeuronEnviron( "./modelBase", "./modelBase/global_mechanisms" )
        # Load in our topology
        network = netEnv.loadTopology( netName )
        # Get the output path
        simOutPath = os.path.join( outDir, outName )
        # Run the simulation passing the status pipe
        netEnv.runSimulation( simOutPath, pipe )

    # Kill the process
    sys.exit( 0 )

import time

import numpy as np
import multiprocessing
from multiprocessing import Process, Pipe, Value
import json
import math
from io import StringIO
import sys
import re

if not os.path.exists( outDir ):
    os.makedirs( outDir )

# Get all network files (.xml)
validFiles = [ ( x, int( re.search( "[0-9]+", x )[ 0 ] ) )
                for x in os.listdir( netDir ) if x.endswith( ".xml" ) ]
validFiles.sort( key=lambda val:val[ 1 ] )

# Decide how many cores to run on
numAvailCpus = multiprocessing.cpu_count()
numProcs = int( numAvailCpus/2 ) 
# Create the per-process data
procHandles = [ None ] * numProcs
# Keep track of file number, last piped time, and pipe
procInfo = [ ]
# Work out which CPU core to run on, i.e. distribute the load
getAffinity = lambda pId : ( pId * 2 ) % ( numAvailCpus ) +\
               ( 1 if( pId * 2 >= numAvailCpus and numAvailCpus % 2 == 0 )\
                   else 0 )
for i in range( numProcs ):
    procInfo.append( [ 0, 0, Value( 'L', 0 ), getAffinity( i ) ] )

curFile = startOffset
finished = False
startTime = time.time()
throughput = 0.0

# Loop over each network file
while curFile < len( validFiles ) and not finished:
    finished = True
    # Loop over each processor
    for i in range( numProcs ):
        # Check if the processor is running a simulation
        if not procHandles[ i ] or not procHandles[ i ].is_alive():
            # If not currently running a simulation, start one
            if curFile < len( validFiles ):
                if( procHandles[ i ] and procHandles[ i ].exitcode ):
                    # If the last process died unexpectedly, print a warning
                    print( "\nERROR: Thread %i exited with code %i."
                            % ( i, procHandles[ i ].exitcode ) )
                # Get the simulation time in seconds
                simTime = time.time() - startTime
                # Get the throughput in sims/min
                throughput = ( ( curFile - startOffset ) / simTime ) * 60.0
                # Get the next valid network file
                nextFile = validFiles[ curFile ][ 0 ]
                procInfo[ i ][ 0 ] = curFile      
                nextFile = os.path.join( netDir, nextFile )
                outName = "%s-%02i" % ( outBase, curFile )
                curFile += 1
                # Start the simulation on this processor
                procHandles[ i ] = Process( target=runSim, 
                                            args=( nextFile, 
                                                   outName, 
                                                   procInfo[ i ][ 2 ],
                                                   procInfo[ i ][ 3 ]
                                                 )
                                           )
                procHandles[ i ].start()
                finished = False
        else:
            finished = False

    # Output the current status of all the processes, once per loop
    sys.stdout.write('\r')
    sys.stdout.flush()
    sys.stdout.write( "Process/file/sim time | " )
    for i in range( numProcs ):
        pFile = procInfo[ i ][ 0 ]
        pTime = procInfo[ i ][ 2 ].value
        sys.stdout.write( "%i/%i/%i | " % ( i, pFile, pTime ) )
    sys.stdout.write( "Throughput %i sims/min" % throughput )
    sys.stdout.flush()
    time.sleep( 0.001 )
\end{lstlisting}